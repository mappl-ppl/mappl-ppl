# Experimental Evaluation

Ensure you have the nix shell running by following the steps in the root README.

Verify all executables are install:
```console
paht_to/mappl$ mappl --help 
mappl compiler
  mappl SUBCOMMAND
=== subcommands ===
  dump-pyro                  . perform ANF conversion into pyro code generation
  dump-rust                  . rust code generation
  hoist                      . lambda hoisting
  only-parse                 . only parse
  type-check                 . type check
  var-elim                   . variable elimination
  version                    . print version information
  help                       . explain a given subcommand (perhaps recursively)


paht_to/mappl$ perplc --help
perplc: unrecognized option `--help'
usage: perplc [OPTION ...] INFILE.ppl
  -m            Don't monomorphize (implies -lec)
  -l            Don't linearize (implies -ec)
  -e            Don't eliminate recursive datatypes (implies -c)
  -c            Compile only to PPL code (not to FGG)
  -z            Compute sum-product
  -o OUTFILE    Output to OUTFILE
  -O LEVEL      Optimization level (0 = off, 1 = on)
  -d DTYPE      Defunctionalize recursive datatype DTYPE
  -r DTYPE      Refunctionalize recursive datatype DTYPE


paht_to/mappl$ dice --help 
Evaluate a dice program. By default, prints the joint probability of each returned variable in depth-first order.
  dice FILENAME
=== flags ===
  [-branch-elimination]   optimize dice program before compilation using branch
                          elimination
  [-determinism]          optimize dice program before compilation using
                          determinism
  [-eager-eval]           eager let compilation
  [-flip-lifting]         optimize dice program before compilation using flip
                          lifting
  [-inline-functions]     inline all function calls
  [-json]                 print output as JSON
  [-max-list-length _]    maximum list length
  [-num-recursive-calls]  show the number of recursive calls invoked during
                          compilation
  [-print-function-bdd]   print final compiled function state BDD (in graphviz
                          format)
  [-print-state-bdd]      print final compiled state BDD (in graphviz format)
  [-recursion-limit _]    maximum recursion depth
  [-sample _]             number of samples to draw
  [-show-function-size]   print size of all function BDDs
  [-show-internal]        print desugared dice program
  [-show-parsed]          print parsed dice program
  [-show-size]            show the size of the final compiled BDD
  [-show-unparsed]        print unparsed desugared dice program
  [-skip-table]           skip printing the joint probability distribution
  [-build-info]           print info about this build and exit
  [-version]              print the version of this build and exit
  [-help]                 print this help text and exit
                          (alias: -?)


paht_to/mappl$ python -c "import pyro; print(pyro.__version__)"
1.8.6
```

Save the current path to the current working directly for later use:
```shell
HERE=$(pwd)
```

## table of contents
| Figures in the paper | folder                   | 
| -------------------- | ------------------------ | 
| Figure 7 (a)         | hmm                      | 
| Figure 7 (b)         | hmm2                     |
| Figure 7 (c) (d)     | pcfg                     |
| Figure 8 (a) (b)     | hmm_mixed_beta_bernoulli |
| Figure 8 (c)         | hmm_mixed_beta_normal    |

## Figure 7(a): hmm
Source code for this figure is in the `hmm` folder.
- `hmm.enum.py`: enumeration-based inference using Pyro
- `hmm.mappl`: MAPPL model
- `hmm.perpl.pl`: PERPL model
Run `make plot` to automate steps 1â€“6 below.

1. To perform variable elimination on the MAPPL model, run:
    ```shell
    cd ${HERE}/hmm
    make hmm.hoisted.mappl
    ```
    This will generate two files: 
    - `hmm.debug.mappl` is the MAPPL program generated by the variable-elimination pass.
    - `hmm.hoisted.mappl` is the MAPPL program generated by a further closure-conversion and hoisting pass.

2.  ```shell
    make hmm.mappl.py
    ``` 
    compiles `hmm.hoisted.mappl` (MAPPL program) to `hmm.mappl.py`(Python program).

3.  ```shell
    make bench.enum # ~20 minutes
    ``` 
    benchmarks the enumeration program, recording the running time, model evidence, and parameters in a `csv` file.

4.  ```shell
    make bench.mappl # ~3 minutes
    ``` 
    similarly benchmarks the MAPPL implementation.

5.  ```shell
    make bench.perpl # ~3 hours
    ``` 
    similarly benchmarks the PERPL implementation.

6.  ```shell
    make bench.plot
    ``` 
    reproduces Figure 7(a), saved in `hmm.png`. 

Running `make clean` will remove the files generated in the above steps.

## Figure 7(b): hmm2
Source code for this figure is in the `hmm2` folder. Reproduction steps are similar to 7a with different file names.

1.  ```shell
    cd ${HERE}/hmm2
    ```

2.  ```shell
    make hmm2.mappl.py
    ```
    compiles `hmm2.hoisted.mappl` to Python code and generates `hmm2.mappl.py`.

3.  ```shell
    make bench.enum # ~20 minutes
    ```
    benchmarks the enumeration program, recording the running time, model evidence, and parameters in a `csv` file.

4.  ```shell
    make bench.mappl # ~3 minutes
    ```
    similarly benchmarks the MAPPL implementation.

5.  ```shell
    make bench.perpl # ~3 hours
    ```
    similarly benchmarks the PERPL implementation.

6.  ```shell
    make bench.plot
    ```
    reproduces Figure 7(b), saved in `hmm2.png`. 

Again, run `make plot` to automate the process.

## Figure 7(c) 7(d): pcfg
Source code for both figures is in the `pcfg` folder. An environment variable `STOPPROB` must be set when invoking the benchmark script. Prefix every command with `STOPPROB=0.5` to reproduce Figure 7(c), and `STOPPROB=0.9` to reproduce Figure 7(d). To automate the steps below, run `STOPPROB=0.5 make plot` and `STOPPROB=0.9 make plot`.

0.  ```shell
    cd ${HERE}/pcfg
    ``` 

1.  ```shell
    make pcfg.hoisted.mappl
    ``` 
    generates two files: 
    - `pcfg.debug.mappl` is the MAPPL program generated by the variable-elimination pass.
    - `pcfg.hoisted.mappl` is the MAPPL program generated by a further closure-conversion and hoisting pass.
    ```shell
    make pcfg.mappl.py
    ``` 
    compiles `pcfg.hoisted.mappl`(MAPPL program) to `pcfg.mappl.py`(Pythyon program).

2. ```shell
    make pcfg.base.mappl.py
    ``` 
    is similar, but generates Pyro code corresponding to the original program, without the variable elimination transformation applied.

3.  ```shell
    STOPPROB=0.5 make bench.enum # ~5 minutes
    ```
    benchmarks the enumeration program, outputting time, model evidence, and parameters in in a `csv` file.

4.  ```shell
    STOPPROB=0.5 make bench.base # ~20 minutes
    ```
    similarly benchmarks the base program (variable elimination without factorization).

5.  ```shell
    STOPPROB=0.5 make bench.mappl # ~3 minutes
    ```
    similarly benchmarks the MAPPL program with variable elimination.

6.  ```shell
    STOPPROB=0.5 make bench.perpl # ~5 hours, lower perpl_len at the top of the Makefile if this is too long
    ```
    similarly benchmarks the PERPL implementation.

7.  ```shell
    STOPPROB=0.5 make bench.dice # ~15 minutes
    ```
    similarly benchmarks the DICE implementation.

8.  ```shell
    STOPPROB=0.5 make bench.plot
    ```
    reproduces Figure 7(c), saved at `pcfg_0.5.png`. 

Rerun steps 3-8 with `STOPPROB=0.9` to reproduce Figure 7(d). Running `make clean` will remove the files generated in the above steps.

## Figure 8(a)  8(b): hmm_mixed_beta_bernoulli
Source code for both figures is in the `hmm_mixed_beta_bernoulli` folder. An environment variable `HORIZON` must be set when invoking the benchmark script. Prefix every command with `HORIZON=32` to reproduce Figure 8(a), and `HORIZON=64` to reproduce Figure 8(b). To automate the steps below, run `HORIZON=32 make plot` and `HORIZON=64 make plot`.

0.  ```shell
    cd ${HERE}/hmm_mixed_beta_bernoulli
    ```

1.  ```shell
    make hmm_mixed.hoisted.mappl
    ```
    generates two files: 
    - `hmm_mixed.debug.mappl` is the MAPPL program generated by the variable-elimination pass.
    - `hmm_mixed.hoisted.mappl` is the MAPPL program generated by a further closure-conversion and hoisting pass.
    ```shell
    make hmm_mixed.mappl.py
    ```
    compiles `hmm_mixed.hoisted.mappl`(MAPPL program) to `hmm_mixed.mappl.py`(Pythyon program).

2.  ```shell
    HORIZON=32 make bench.is # ~1 hour
    ```
    benchmarks the base program running importance sampling, and outputs time, model evidence, and parameters in in a `csv` file.

3.  ```shell
    HORIZON=32 make bench.mappl # ~1.5 hours
    ```
    similarly benchmarks the MAPPL program with importance sampling.

4.  ```shell
    HORIZON=32 make bench.exact
    ```
    uses symbolic integration to calculate the exact solution to the inference problem, outputting to a `csv` file.

5.  ```shell
    HORIZON=32 make bench.plot
    ```
    reproduces Figure 8(a), saved at `beta-bern_32.png`

Rerun steps 2-5 with `HORIZON=64` to reproduce Figure 8(b). Running `make clean` will remove the files generated in the above steps.

## Figure 8(c): hmm_mixed_beta_normal
Source code is in the `hmm_mixed_beta_normal` folder. To automate the steps below, run `make plot`.

0.  ```shell
    cd ${HERE}/hmm_mixed_beta_normal
    ```

1.  ```shell
    make hmm_mixed.hoisted.mappl
    ```
    and 
    ```
    make hmm_mixed.mappl.py
    ```
    behave identically as for Figure 8(a) and 8(b).

2.  ```shell
    make bench.is # ~1 hour
    ```
    benchmarks the base program running importance sampling, and outputs time, model evidence, and parameters in in a `csv` file.

3.  ```shell
    make bench.mappl # ~1.5 hours
    ```
    similarly benchmarks the MAPPL program with importance sampling.

4.  ```shell
    make bench.exact
    ```
    uses symbolic integration to approximate the solution to the inference problem, outputting to a `csv` file.

5.  ```shell
    make bench.plot
    ```
    reproduces Figure 8(a), saved at `beta-normal_16.png`

Running `make clean` will remove the files generated in the above steps.
